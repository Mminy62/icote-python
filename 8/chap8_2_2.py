'''
최대 100 사이즈의 배열에서 인접한 것을 피해 얻을 수 있는 최대값은?
최대값..
구현을 하기엔 규칙이 보임
dp -?

dp의 배열 기준은 뭘로?
인접한게 아닌 조합은 졸라 많아
그중에서도 최대값을 찾는다? 졸라 소모된다.
갯수로 배열의 기준을 정한다.? -> 나쁘진 않음 -> 값을 넣는 걸 다시 생각해봐야함
그 많은 것들 중 인접하지 않고 최대값 3개를 고른다.?
아..
배열을 돌면서 왼 -> 오로
값이 선택되면 왼쪽에선 가장 큰 값이 무엇인지 확인
그럼 인접 왼왼만 더하면 됨

1, 2, 3, 4, 5
dp[0] = 0
dp[1] = 1
dp[2] = 2 -> max(2 + dp[0], dp[1])
dp[3] = max(4, dp[2]) -> 4
dp[4] = max(4 + dp[2], dp[3]) -> 6
dp[5] = max(5 + dp[3], dp[4]) -> 8

1 3 1 5
dp[0] = 0
dp[1] = 1
dp[2] -> max(3 + dp[0] , dp[1]) = 3
dp[3] -> max(1 + dp[1], dp[2]) = 3
dp[4] -> max(5 + dp[2], dp[3]) = 8

Input
4
1 3 1 5
'''

n = int(input())
array = list(map(int, input().split()))

dp = [0] * (n + 1)
dp[1] = array[0]

for i in range(1, n):
    dp[i + 1] = max(array[i] + dp[i-1], dp[i])

print(dp[n])